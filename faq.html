<!DOCTYPE html>
<html lang="en">
  <head>
    <!--# include file="/templates/header.html" -->
    <title>Egison - FAQ</title>
  </head>
  <body data-spy="scroll" data-target=".bs-sidebar" data-offset="0">
    <!--# include file="/templates/navbar.html" -->

    <div class="container manual">

      <div class="row">

        <div class="col-md-12" id="top" role="complementary">
          <h1>Questions and Answers</h1>
        </div>

      </div>

      <div class="row">

        <div class="col-md-12" role="main">

          <hr/>
          
          <ul>
            <!--# include file="/templates/faq.html" -->
          </ul>
          
          <hr/>
          
          <h2 id="what-is-egison">What is Egison?</h2>

          <p>
            Egison is the programming language that realized non-linear pattern-matching against unfree data types.<br/>
            It enables us to represent pattern-matching against lists, multisets, sets, trees, graphs and any kind of data types, directly.<br/>
            For example, we can represent a pattern-matching against sets.<br/>
            It is difficult in the existing languages because a collection <i>{a, b, c}</i> is equal with <i>{b, a, c}</i> and <i>{a, a, b, c}</i>, when we see them as sets, and
            the pattern-matching of the existing programming languages only support data types whose data have a standard form, such as lists.<br/>
            Therefore, we need to translate and regard them as data which have a canonical form when we treat these kinds of data.
            For example, a set would be always treated as a list.<br/>
            Many programmers think this is unavoidable, and in fact, it is a latent stress of programming.<br/>
            Egison gets rid of this restriction and makes programming dramatically simple!
          </p>

          <h2 id="why-new-language">Why new language?</h2>

          <p>
            Implementation of the Egison pattern-matching has big influence for whole design of a programming language.<br/>
            The patterns and the new notions <i>matchers</i>, which defines how to pattern-matching for each data type, have really important role as functions.<br/>
            What was the best design changes by introducing this new pattern-matching.<br/>
            Additionally, I had to do a lot of experiments to theorize it.<br/>
          </p>

          <h2 id="how-to-contribute">How to contribute?</h2>
          
          <p>
            Please try Egison and give <a target="_blank" href="/~egi/">me</a> feedback.<br/>
            If it is interesting for you, please talk and tweet about Egison.<br/>
            What is the happiest thing for me is to read Egison code by the people with various backgrounds.<br/>
            I believe Egison will be helpful and give breakthrough for the various fields.<br/>
          </p>
          <p>
            I really appreciate if you could create the extensions for the other languages such as Haskell, Python and JavaScript.<br/>
            I think these work will have great impact.<br/>
            I'd like to do that by myself.<br/>
            However, I don't have thorough knowledge of each language to implement extensions, yet.<br/>
            I've already implemented <a target="_blank" href="https://github.com/egison/egison-ruby">the Ruby extension</a>.
          </p>
          
          <h2 id="logic-programming">What is a difference between logic programming?</h2>
          
          <p>
            Pattern-matching of Egison is realized with backtracking as Prolog.<br/>
            The difference is that Egison realized these strong expression in pattern-matching.<br/>
            The pattern-matching itself of Prolog is similar with ordinal pattern-matching of the other functional languages.<br/>
            The mechanism of pattern-matching is briefly written <a href="/manual/mechanism.html">here</a>.
          </p>

          <h2 id="related-work">What is the advantage of Egison over existing work?</h2>

          <p>
            There are <a target="_blank" href="https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#Relatedwork">a lot of existing work</a> for pattern-matching.
          </p>

          <p>
            The advantage of Egison is that it realized <b>all of the following features</b> at the same time.
          </p>

          <ul>
            <li>Modularization of the way of pattern-matching for each data type</li>
            <li>Pattern-matching with multiple results (backtracking)</li>
            <li>Non-linear pattern-matching</li>
          </ul>

          <p>
            It enables us to express non-linear pattern-matching against unfree data types intuitively as above demonstrations.
          </p>

          <p>
            Furthermore, Egison realized the following feature.
            We can even modularize patterns like functions keeping above features.
          </p>

          <ul>
            <li>Non-linear pattern-matching with <b>lexical scoping</b></li>
          </ul>

          <p>
            The <a href="/manual/mechanism.html">Pattern-Matching Mechanism</a> section in Egison developer's manual explains how we realized that.
          </p>

          <h2 id="scripting">How to write scripts in Egison?</h2>

          <p>
            Please read the <a href="/manual/io.html">IO</a> section in our manual. We are providing simple examples.
          </p>

          <h2 id="next">Next Action...</h2>
          
          <p>
            <a class="btn btn-lg btn-primary" href="/" role="button">Back to Home</a>
          </p>
          
        </div>

      </div><!--/row-->
    
      <hr class="divider">
      
      <div class="row">
        <!--# include file="/templates/disqus-main.html" -->
      </div><!--/row-->
      
    </div><!-- /.container -->
    
    <!--# include file="/templates/footer.html" -->
  </body>
</html>
