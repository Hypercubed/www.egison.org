<!DOCTYPE html>
<html lang="en">
  <head>
    <!--# include file="/templates/header.html" -->
  </head>
  <body data-spy="scroll" data-target=".bs-sidebar" data-offset="0" onload="prettyPrint()">
    <!--# include file="/templates/navbar.html" -->

    <div class="container manual">

      <div class="row">

        <div class="col-md-12" id="top" role="complementary">
          <h1>Pattern Matching</h1>
        </div>

      </div>

      <div class="row">

        <div class="col-md-12" role="main">

<p>
  How do you express a set in a program?
  Probably, most of you represents it as a list.
  However, a list differs from a set in that it has the order.
  Then, even if you want to ignore the order, you have to care about it when we represent a set as a list.
  Data such as sets have no normal form, and are called <i>unfree data</i>.
  Unfortunately, it had been difficult to do pattern matching for them until Egison was introduced.
  Egison gives strong pattern matching for those data.
  We demonstrate it here with many examples, which contain pattern matching for lists, multisets, and sets.
</p>

<hr/>

<ul>
  <li><a href="#pattern-matching1">Pattern Matching with Backtracking</a></li>
  <li><a href="#pattern-matching2">Non-linear Pattern Matching with Backtracking!!</a></li>
  <li><a href="#loop-patterns">Loop-Patterns</a></li>
  <li><a href="#first-class-pattern-functions">First Class Pattern-Functions</a></li>
</ul>

<hr/>



<h2 id="pattern-matching1">Pattern Matching with Backtracking</h2>

<p>
  In this section, we show various basic pattern matching for collections, such as lists, multisets, and sets.
  At first, let's execute the following code.
  We explain its meaning later.
</p>

<textarea class="code">&gt; (match-all {1 2 3 4} (list integer)
          [&lt;cons $x $xs&gt; [x xs]])
{[1 {2 3 4}]}

&gt; (match-all {1 2 3 4} (multiset integer)
          [&lt;cons $x $xs&gt; [x xs]])
{[1 {2 3 4}] [2 {1 3 4}] [3 {1 2 4}] [4 {1 2 3}]}

&gt; (match-all {1 2 3 4} (set integer)
          [&lt;cons $x $xs&gt; [x xs]])
{[1 {1 2 3 4}] [2 {1 2 3 4}] [3 {1 2 3 4}] [4 {1 2 3 4}]}</textarea>

<p>
  All of them say "take an element from the collection <code>{1 2 3 4}</code>".
  If you regard <code>{1 2 3 4}</code> as a list, you will take the head <code>1</code>.
  However, if you assume the collection is a set, which element you should take
  The set {1 2 3 4} has forms such as {2 1 4 3}, {4 3 2 1}, {1 2 1 3 1 4 1}, and so on.
  If you take the "head" of the set, you will get 1, 2, 3, or 4.
  Egison returns all of them.
  That is, a <code>match-all</code> expression returns the collection of results of an evaluation of the formula with the matched pattern.
  Since an unfree datum has no normal form but many forms as explained above, the collection can have multiple elements.
</p>

<p>
  As explained in the previous chapter, the arguments of a <code>match-all</code> expression are a target, a matcher, a pattern, and a formula.
  The pattern and the formula construct a <i>match-clause</i>, and the formula is called the <i>body</i> of the match-clause.
  That is, a <i>match-clause</i> has the form <code>[<i>pattern</i> <i>body</i>]</code>.
  In the above examples, their match-clauses are all "<code>[&lt;cons $x $xs&gt; [x xs]]</code>", and the body of it is "<code>{[x xs]}</code>".
  A match-clause defines a sequence of actions in the pattern matching.
  In this case, it means "deconstruct an object in the way defined as cons, and then bind <code>x</code> and <code>xs</code> to adequate objects".
  The meaning of <code>cons</code>, i.e., what kind of objects matches and where <code>x</code> and <code>xs</code> are bound depends on matchers.
  In general, it divides a collection into an element and the rest of the collection.
  If a matcher is <code>list</code>, <code>x</code> is the head of the collection and <code>xs</code> is the rest as ordinary programming languages.
  For example, in the above case, <code>x</code> is 1 and <code>xs</code> is {2 3 4}.
  In the case of <code>multiset</code>, that is, a matcher of a collection whose order is meaningless, <code>x</code> is bound to any element in the target.
  The above example shows the possible pairs <code>[x xs]</code> are <code>[1 {2 3 4}]</code>, <code>[2 {3 4 1}]</code>, <code>[3 {4 1 2}]</code>, and <code>[4 {1 2 3}]</code>.
  Note its order is also meaningless.
  When the numbers of occurrences of elements in the collection is also meaningless, that is, it is a set, an element where <code>x</code> are bound can be contained in the collection that <code>xs</code> are bound to.
  You can confirm the fact by the above example.
</p>

<p>
  Of course, there are inductive patterns for collections other than <code>cons</code>.
  Here is another example, <code>join</code>.
</p>

<textarea class="code">&gt; (match-all {1 2 3} (list integer)
          [&lt;join ,{1} $xs&gt; xs])
{{2 3}}
&gt; (match-all {1 2 3} (multiset integer)
          [&lt;join ,{1} $xs&gt; xs])
{{2 3}}
&gt; (match-all {2 1 3} (list integer)
          [&lt;join ,{1} $xs&gt; xs])
{}
&gt; (match-all {2 1 3} (multiset integer)
          [&lt;join ,{1} $xs&gt; xs])
{{2 3}}</textarea>

<p>
<code>join</code> is a pattern that divides a collection into two collections, the two arguments of it.
  Intuitively, <code>join</code> is "<code>cons</code> iteration".
  That is, <code>&lt;join $x $y&gt;</code> is <code>&lt;cons $x1 &lt;cons $x2 &lt;...&lt;cons $xn $y&gt;...&gt;&gt;&gt;</code> and <code>x</code> is equal to <code>{x1 x2 ... xn}</code>.
  Matchers <code>list</code> and <code>multiset</code> are equipped with <code>join</code>.
  The way <code>list</code> divides a collection preserves the order of the collection.
  For example, all matches <code>&lt;join ,{1 2} ,{3}&gt;</code> is <code>{1 2 3}</code>.
  By contrast, <code>multiset</code> breaks the order.
  In the example, the pattern is matched by <code>{1 2 3}</code>, <code>{1 3 2}</code>, <code>{2 1 3}</code>, and so on.
</p>

<p>
  An interesting example using <code>cons</code> and <code>join</code> is non-deterministic pattern matching for a list.
  For example, you want to divide even-number elements by 2 recursively.
  The following function <code>div2</code> gives the list you want to get.
  You may be able to confirm the function works correctly.
  Note that there is no guarantee that <code>div2</code> divides elements from the head.
</p>

<textarea class="code">&gt; (define $div2
     (lambda [$x]
        (match x (list integer)
           {[&lt;join $xs &lt;cons (&amp; ?(lambda [$x] (eq? (modulo x 2) 0)) $y) $zs&gt;&gt;  (div2 {@xs (quotient y 2) @zs})]
            [_ x]})))
&gt; (div2 {1 1 2 3 5 8 13 21 34 55 89 144 233 377 610})
{1 1 1 3 5 1 13 21 17 55 89 9 233 377 305}</textarea>

<p>
  The matcher <code>list</code> can deconstruct a collection into the tail and the others.
  The inductive pattern, named <code>snoc</code>, is the "dual" of <code>cons</code>.
  Of course, since a (multi)set has no order, neither <code>multiset</code> nor <code>set</code> has <code>snoc</code>.
  Similarly, <code>list</code> also has the "dual", <code>nioj</code>, of <code>join</code>.
</p>

<textarea class="code">&gt; (match-all {1 2 3} (list integer)
          [&lt;snoc $x $xs&gt; [x xs]])
{[3 {1 2}]}
      
&gt; (match-all {1 2 3} (list integer)
          [&lt;nioj $xs $ys&gt; [xs ys]])
{[{1 2 3} {}] [{2 3} {1}] [{3} {1 2}] [{} {1 2 3}]}</textarea>

<p>
  The arguments of <code>snoc</code> matches with the last element of a target collection and the rest of it.
  Note that, in Egison, extraction of an element from the tail of a collection is represented in the same way as the head of it.
  A pattern constructor <code>nioj</code> is similar to <code>join</code>, and used to divide a target collection into two collections.
  The difference between <code>join</code> and <code>nioj</code> is the order of pattern matching, as its name suggests.
  In case of <code>nioj</code>, pattern matching is executed from the back-side of a collection.
  The order of pattern matching is important when we do pattern matching using non-linear patterns, which we will discuss in the next section.
</p>

<h2 id="pattern-matching2">Non-linear Pattern Matching with Backtracking!!</h2>

<p>
  Egison allows programmers to "bind and use" variables in a pattern.
  A pattern that contains multiple occurrences of a variable is called a <i>non-linear pattern</i>.
  Egison is the first programming language that non-linear patterns can be used in pattern matching for unfree data.
  The following is an example of non-linear patterns.
</p>

<textarea class="code">&gt; (match-all {1 2 3 1 2} (multiset integer)
          [&lt;cons $n &lt;cons ,n _&gt;&gt; n])
{1 2 1 2}</textarea>


<p>
  The output of this example is the collection of numbers duplicated in the target collection.
</p>

<p>
  Since Egison executes pattern matching from left to right,
  a bound variable can be referred to in its right side of the pattern.
  In this example, at first, the variable <code>n</code> is bound to any element of the collection.
  Then, Egison examines the pattern <code>,n</code>.
  It places the right side of <code>$n</code>, it is evaluated to the value where <code>n</code> is bound.
  When an object matches the pattern <code>,n</code>, it is equal to the value as 
<code>integer</code>.
  Therefore, after successful pattern matching, <code>n</code> is bound to an element contained at least two in the target collection.
</p>

<p>
  Here is another example.
  Suppose you have three collections of integers, and need the integers contained in all of the collections.
  You can do the task using the following simple code.
</p>

<textarea class="code">&gt; (match-all {{1 2 3 4 5} {4 5 1} {6 1 7 4}} (list (multiset integer))
          [&lt;cons &lt;cons $n _&gt; &lt;cons &lt;cons ,n _&gt; &lt;cons &lt;cons ,n _&gt; &lt;nil&gt;&gt;&gt;&gt; n])
{1 4}</textarea>

<p>
  Probably, you understand how strong the pattern matching of Egison is.
  In this chapter, we show the inductive patterns of the matchers <code>list</code>, <code>multiset</code>, and <code>set</code>.
  If you want to make your own matcher or understand matchers more deeply, you should read the next chapter.
</p>

<hr/>

<h3 id="loop-patterns">Loop-Patterns</h3>

<p>
  Can you write a function <code>comb2</code> that takes a collection as the argument, and returns the 2-combinations of it?
  This is an easy exercise, and our answer is as follows.
</p>

<textarea class="code">(define $comb2
  (lambda [$xs]
    (match-all xs (list something) 
      [<join _ <cons $a_1 <join _ <cons $a_2 _>>>> [a_1 a_2]])))

(comb2 {1 2 3 4 5})
;=>{[1 2] [1 3] [2 3] [1 4] [2 4] [3 4] [1 5] [2 5] [3 5] [4 5]}</textarea>

<p>
  Next, can you write a <code>comb3</code>?
  You will easily rewrite <code>comb2</code> to <code>comb3</code> as follows.
</p>

<textarea class="code">(define $comb3
  (lambda [$xs]
    (match-all xs (list something) 
      [<join _ <cons $a_1 <join _ <cons $a_2 <join _ <cons $a_3 _>>>>>> [a_1 a_2 a_3]])))

(comb3 {1 2 3 4 5})
;=>{[1 2 3] [1 2 4] [1 3 4] [2 3 4] [1 2 5] [1 3 5] [1 4 5] [2 3 5] [2 4 5] [3 4 5]}</textarea>

<p>
  If you can, how about <code>comb4</code>, <code>comb5</code>, and so on?
  Patterns in these <code>combX</code> have the same form, <code>&lt;join _ &lt;cons $a_1 &lt;join _ &lt;cons $a_2 ... _&gt;...&gt;&gt;&gt;</code> and then it seems to be possible to generalise them.
  We can do such a thing using a loop-pattern.
</p>

<pre><code> (loop <i>variable</i> <i>range</i> <i>formula</i> <i>formula</i>)
</code></pre>

<p>
The arguments of a loop-pattern represent an index-variable, a range of the index, a pattern repeated, and a pattern representing the end.
When the pattern ran all range, a loop-pattern is "the same as" the last argument.
Otherwise, it is "the same as" the third argument substituted itself for <code>...</code> and the head of the second argument for the index-variable with removing the head of the second argument.
It is probably difficult to understand what it means.
Then, we give <code>comb</code> as an example, and will describe the meaning of a loop-pattern using the example.
It's roughly correct and easier to understand.
</p>

<textarea class="code">(define $comb
  (lambda [$xs $n]
    (match-all xs (list something)
      [(loop $i [1 n]
         <join _ <cons $a_i ...>>
         _)
       (map (lambda [$i] a_i) (between 1 n))])))

(comb {1 2 3 4 5} 3)
;=>{{1 2 3} {1 2 4} {1 3 4} {2 3 4} {1 2 5} {1 3 5} {1 4 5} {2 3 5} {2 4 5} {3 4 5}}
</textarea>

<p>
We consider the case <code>n</code> is three.
Then, a loop-pattern is 
</p>

<textarea class="code">(loop $i {1 2 3}
  <join _ <cons $a_i ...>>
  _)</textarea>

<p>
When the range of the index is non-null, a loop-pattern "returns" the third argument regarding <code>...</code> in the argument as the loop-pattern itself.
Since <code>{1 2 3}</code> isn't null, the above example is "evaluated to"
</p>

<textarea class="code"><join _ <cons $a_1 (loop $i [2 3]
  <join _ <cons $a_i ...>>
  _)>></textarea>

<p>
Note that in the "evaluation", the index-variable <code>i</code> is "replaced with" the head of the collection, <code>1</code> in the example.
Moreover, the collection argument of the loop-pattern loses its head.
That is, <code>{1 2 3}</code> is "replaced with" <code>{2 3}</code>
Repeating this "evaluation", 
</p>

<textarea class="code"><join _ <cons $a_1 <join _ <cons $a_2 <join _ <cons $a_3 (loop $i [3 3]
  <join _ <cons $a_i ...>>
  _)>>>>>></textarea>

<p>
In the case, the second argument of the loop-pattern is null, Egison "evaluates" the last argument <code>_</code>. Then,
</p>

<textarea class="code"><join _ <cons $a_1 <join _ <cons $a_2 <join _ <cons $a_3 _>>>>>></textarea>

<p>
It is the same as what we used in <code>comb3</code>!
Actually, since a loop-pattern is just a pattern, Egison doesn't evaluate a loop-pattern.
However, a claim that the above patterns are the same is true.
Then, recalling "the result of evaluation", you can use a loop-pattern.
</p>

<p>
In the above, we omit explanation of restriction.
<code>...</code> must be placed at the end of the second argument.
For example, <code>&lt;cons ... &lt;nil&gt;&gt;</code> is prohibited.
This restriction decides which loop-patterns a given <code>...</code> belongs to, and then allows us to write nested loop-patterns.
</p>

<p>
By the way, you can omit the last argument of a loop-pattern.
In such a case, Egison regards the last argument is <code>^_</code>, which is a pattern that no objects match.
For example,
</p>

<textarea class="code">(loop $i [1 n]
  <join _ <cons $a_i ...>>)</textarea>

<p>
is interpreted as 
</p>

<textarea class="code">(loop $i [1 n]
  <join _ <cons $a_i ...>>
  ^_)</textarea>

<hr/>

<h2 id="first-class-pattern-functions">First Class Pattern-Functions</h2>

<p>
  You can reuse a pattern via a pattern-function.
  A <a href="./patterns.html#pattern-function">pattern-function</a> is a function that takes patterns and returns a pattern.
</p>

<p>
  Patterns are not first class objects.
  So you can NOT replace a pattern with an object, and vice versa.
  For example, <code>(test _)</code> is illegal, because <code>_</code> is not an object but a pattern as shown below.
  However, pattern-functions are first class objects.
  So you can define pattern-functions and apply it as an argument of a function in anywhere of programs.
</p>

<p>
  Egison programmers reuse a pattern via a pattern-function.
  Although this restriction seems to be too strict, this makes modularisation of patterns clear.
</p>

<p>
  See <a href="./mahjong.html">mahjong example</a> to see how to use pattern-functions.
</p>

<hr/>

<p>
We recomment you to read the chapter <i><a href="./mechanism.html">Pattern Matching Mechanism</a></i>, if you are interested in the mechanism of Egison pattern matching.
</p>

        </div>

      </div><!--/row-->
    
    </div><!-- /.container -->
    
    <!--# include file="/templates/footer.html" -->
    <script>
      $('.code').each(function() {
        var $this = $(this);
        var myCodeMirror = CodeMirror.fromTextArea(this, {
          readOnly: "nocursor",
          lineWrapping: true
        });
      });
    </script>
  </body>
</html>
