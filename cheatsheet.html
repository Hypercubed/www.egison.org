<!DOCTYPE html>
<html lang="en">
  <head>
    <!--# include file="/templates/header.html" -->
  </head>
  <body data-spy="scroll" data-target=".bs-sidebar" data-offset="0">
    <!--# include file="/templates/navbar.html" -->

    <div class="container manual">

      <div class="row">

        <div class="col-md-6" id="top" role="complementary">
          <h1>Egison Cheat Sheet</h1>
        </div>

      </div>

      <div class="row">

        <div class="col-md-12" role="main">
<ul>
  <li><a href="#top-expressions">Top Expressions</a></li>
  <ul>
    <li><a href="#define-and-test"><code>define</code> and <code>test</code> expressions</a></li>
    <li><a href="#load"><code>load</code> and <code>load-file</code> expressions</a></li>
  </ul>
  <li><a href="#objects">Objects</a></li>
  <ul>
    <li><a href="#builtin">Builtin data</a></li>
    <li><a href="#composed">Composed data</a></li>
    <li><a href="#user-defined">User-defined objects</a></li>
  </ul>
  <li><a href="#syntax">Syntax</a></li>
  <ul>
    <li></li>
  </ul>
</ul>          
        </div>

        <div class="col-md-6" role="main">
<h2 id="top-expressions">Top Expressions</h2>

<h3 id="define-and-test"><code>define</code> and <code>test</code> expressions</h3>

<textarea class="code">(define $x 2)
(test (+ x 3));=>5
  
(define $f (lambda [$x $y] [(+ x y) (* x y)]))
(test (f 2 4));=>[6 8]</textarea>

<h3 id="load"><code>load</code> and <code>load-file</code> expressions</h3>

<textarea class="code">; Load Egison library
(load "lib/core/number.egi")

; Load your program
(load-file "/home/xxx/code/egison/myfile.egi")</textarea>

<h2 id="objects">Objects</h2>

<h3 id="builtin">Builtin data</h3>

<textarea class="code">;; Boolean values
#t ; True
#f ; False

;; Numbers
1
0
-100
  
;; Float numbers
10.2
-100.1

;; Characters
'a'
'1'
'\n'

;; Strings
"Hello world!"</textarea>

<h3 id="composed">Composed data</h3>

<p>
  We have five ways to compose data, <i>inductive data</i>, <i>tuples</i>, <i>collections</i>, <i>arrays</i>, and <i>hashes</i>.
</p>

<textarea class="code">;; Inductive data
<Card <Diamond> 13>
<Node 3 <Node <Leaf 1> <Leaf 2>> <Leaf 4>>

;; Tuples
[]
[1 2]
[#t "abc" 4]
[1];=>1
[[[[[[[[[[["too many"]]]]]]]]]]];=>"too many"

;; Collections
{}
{1 2 3 4 5}
{'a' 'b' 'c'};=>"abc"
{1 @{2 3}};=>{1 2 3}
{@{@{1}} @{2 @{3}}};=>{1 2 3}

;; Arrays
(define $xa [| 1 2 3 4 5 |])
(array-size xa);=>5
xa_0;=>1
xa_4;=>5

;; Hashes
(define $xh {| [1 11] [2 12] [3 13] [4 14] [5 15] |})
xh_1;=>11
xh_4;=>14</textarea>

<p>
  Note that, a tuple that consists of a single element is equal with the element itself.
</p>

<textarea class="code">[1];=>1
[[[[[[[[[[["too many"]]]]]]]]]]];=>"too many"</textarea>

<p>
  Note that we can splice collections using <code>@</code> inside a collection.
</p>

<textarea class="code">{1 @{2 3}};=>{1 2 3}
{@{@{1}} @{2 @{3}}};=>{1 2 3}</textarea>

<h3 id="user-defined">User-defined objects</h3>

<textarea class="code">;; Functions
(lambda [$x] x)
(lambda [$x $y] (* (+ x y) (- x y)))

;; Matcher
something
integer
(list integer)
(multiset integer)
(set integer)
(list (multiset integer))</textarea>

<h2 id="patterns">Patterns</h2>

<textarea class="code">;; Wildcard
_

;; Pattern-variables
$x
$y_1
$z_1_(+ 1 2)
$w_n

;; Value-patterns
,1
,(+ n 10)
,(id 10)

;; Predicate-patterns
?(eq? $ 10);=>,10
?(lt? $ 10)
?even?
  
;; Inductive patterns
<nil>
<cons $x $xs>
<join $xs $ys>
<join _ <cons $x_1 <join _ <cons $x_2 _>>>>

;; Not-patterns
^_
^,10
<cons $x ^<cons ,x _>>

;; And-patterns
(& ,3 $n)

;; Or-patterns
(| ,3 ,4)

;; Loop-patterns
(loop $i [3 {4 5} $n] <cons $x_i ...> _)
;=><cons $x_3 <cons $x_4 (| _ <cons $x_5 _>)>>

; Syntax sugars for loop-patterns
(loop $i [3 {4 5}] <cons $x_i ...> _)
;=>(loop $i [3 {4 5} _] <cons $x_i ...> _)

(loop $i [3 5] <cons $x_i ...> _)
;=>(loop $i [3 {5} _] <cons $x_i ...> _)

(loop $i [3 $n] <cons $x_i ...> _)
;=>(loop $i [3 {3 4 5 ...} $n] <cons $x_i ...> _)

;; Pattern-functions
(pattern-function [$pat] pat)

(pattern-function [$pat1 $pat2]
    <cons (& $pat pat1) <cons ,pat pat2>>)</textarea>

<h2 id="syntax">Syntax</h2>

<h3 id="lambda"><code>lambda</code> expressions</h3>

<p>
  <code>lambda</code> expressions make functions as other functional programming languages.
</p>

<textarea class="code">
((lambda [$x $y] (+ x y)) 3 7);=>10
((lambda $x (not x)) #t);=>#f</textarea>

<p>
  We support partial evaluations.
</p>

<textarea class="code">((+ $ $) 3 4);=>7
((+ $1 $2) 3 4);=>7
((* $1 $1) 5);=>25
((map $2 $1) {1 2 3} (+ $ 1))=>{2 3 4}</textarea>

<h3 id="let"><code>let</code> and <code>letrec</code> expressions</h3>

<p>
  A <code>let</code> and <code>letrec</code> expression are used for local variable bindings.
  The difference is that a <code>letrec</code> expression can used for recursive definitions.
  Mutual recursion is also allowed.
</p>

<p>
</p>

<textarea class="code">(let {[$x 1] [$y 2]} (+ x y));=>3

(letrec {[$evens {2 @(map (+ $ 2) evens)}]}
  (take 10 evens))
;=>{2 4 6 8 10 12 14 16 18 20}

(letrec {[$odds {1 @(map (+ $ 1) evens)}]
         [$evens (map (+ $ 1) odds)]}
  (take 10 evens))
;=>{2 4 6 8 10 12 14 16 18 20}</textarea>

<h3 id="if"><code>if</code> expressions</h3>

<p>
  It's ordinary <code>if</code>.
  But, note the result of an evaluation of the first argument must be a boolean value (i.e. <code>#t</code> or <code>#f</code>).
</p>

<textarea class="code">(if #t "YES" "NO");=>"YES"
(if #f "YES" "NO");=>"NO"</textarea>

<h3 id="match-all"><code>match-all</code> expressions</h3>

<textarea class="code">(match-all {1 2 3} (list integer)
  [<cons $x $xs> [x xs]]);=>{[1 {2 3}]}

(match-all {1 2 3} (multiset integer)
  [<cons $x $xs> [x xs]])
;=>{[1 {2 3}] [2 {1 3}] [3 {1 2}]}

(match-all {1 2 3} (set integer)
  [<cons $x $xs> [x xs]])
;=>{[1 {1 2 3}] [2 {1 2 3}] [3 {1 2 3}]}</textarea>

<h3 id="match"><code>match</code> expressions</h3>

<textarea class="code">(match {1 2 3 4} (list integer)
  {[<nil> #f]
   [<cons $x $xs> [x xs]]});=>[1 {2 3 4}]

(match {1 2 3 4} (set integer)
  {[<nil> #f]
   [<cons $x $xs> [x xs]]});=>[1 {1 2 3 4}]</textarea>

<h3 id="matcher"><code>matcher</code> expressions</h3>

<p>
  This expression is used to define how to pattern-match for each data type.<br/>
  It's too complicated to explain here, so please read <a href="/manual/matchers.html">the manaul</a> for that.
</p>
        </div>
        
        <div class="col-md-6" role="main">
          
<h2 id="pattern-matching">Pattern-matching</h2>

<h3 id="non-linear">Non-linear patterns</h3>

<h3 id="loop-patterns">Loop-patterns</h3>

<h3 id="pattern-function">Modularization of patterns</h3>

<p>
  We can reuse useful patterns with <i>pattern-functions</i>, functions that take patterns and return a pattern.
</p>

<textarea class="code">(define $twin
  (pattern-function [$pat1 $pat2]
    <cons (& $pat pat1) <cons ,pat pat2>>))

(match-all {1 1 2 3} (list integer)
  [(twin $n _) n]);=>{1}

(match-all {1 2 1 3} (multiset integer)
  [(twin $n _) n]);=>{1 1}</textarea>

<h2 id="builtin-functions">Builtin functions</h2>

<h3 id="calculate-numbers">Calculate numbers</h3>

<textarea class="code">(+ 1 2);=>3
(- 30 15);=>15
(* 10 20);=>200
(/ 20 5);=>4
(power 2 10);=>1024

(+ 2/3 1/5);=>13/15
(/ 42 84);=>1/2

(+ 10.2 1.3);=>11.5
(* 10.2 1.3);=>13.26

(rtof 1/5);=>0.2
(rtof 1/100);=>1.0e-2</textarea>

<h2 id="library-functions">Library</h2>

<h3>Infinite collections</h3>

<h3 id="handle-collection">Handling collections</h3>


        </div>
        
      </div><!--/row-->

    </div><!-- /.container -->
    
    <!--# include file="/templates/footer.html" -->
    <script>
      $('.code').each(function() {
        var $this = $(this);
        var myCodeMirror = CodeMirror.fromTextArea(this, {
          readOnly: "nocursor",
          lineWrapping: true
        });
      });
    </script>
  </body>
</html>
